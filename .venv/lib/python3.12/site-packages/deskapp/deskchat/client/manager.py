import time
from typing import Optional, Dict, Any, List

from deskapp.server.client import ClientSession


class _ClientManager:
    def __init__(self):
        self.client: Optional[ClientSession] = None
        self._app = None

    def init_app(self, sink=None, data=None):
        self._app = type('AppWrap', (), {})()
        self._app.sink = sink
        self._app.data = data if data is not None else {}

    def login(self, host: str, port: int, username: str, password: str = '') -> tuple[bool, Optional[str]]:
        try:
            if self.client is not None:
                try:
                    self.client.close()
                except Exception:
                    pass
                self.client = None

            self.client = ClientSession({'host': host, 'port': port}, sink=self._app.sink)
            ok, err = self.client.connect()
            if not ok:
                self.client = None
                return False, err or 'connection failed'

            ok, err = self.client.login(username, password)
            if not ok:
                self.client.close()
                self.client = None
                return False, err or 'login failed'

            # Subscribe to users on successful login.
            self.add_sub('users')
            return True, None
        except Exception as e:
            if self.client:
                try:
                    self.client.close()
                except Exception:
                    pass
                self.client = None
            return False, str(e)

    def logout(self):
        if not self.client:
            return True, None
        try:
            self.client.close()
            self.client = None
            return True, None
        except Exception as e:
            return False, str(e)

    def tick(self):
        if not self.client:
            return
        try:
            self.client.tick()
        except Exception:
            # Swallow exceptions to avoid UI crashes; errors already go to sink.
            pass

    def add_sub(self, topic: str):
        if not self.client:
            return False
        try:
            self.client.subscribe(topic)
            return True
        except Exception:
            return False

    # Status helpers used by UI
    def is_connected(self) -> bool:
        return bool(self.client and self.client.connected)

    def get_username(self) -> Optional[str]:
        return self.client.username if self.client else None

    def get_status(self) -> Dict[str, Any]:
        if not self.client:
            return {'connected': False}
        return {
            'connected': self.client.connected,
            'username': self.client.username,
            'host': self.client.host,
            'port': self.client.port,
        }

    # Local echo chat used by Chat and Log panels
    def chat_local(self, user: str, text: str):
        if not self._app:
            return
        log: List[tuple[str, str]] = self._app.data.setdefault('chat', [])
        log.append((user, text))
        # Keep log bounded
        if len(log) > 5000:
            del log[:len(log)-5000]


_manager = _ClientManager()


def init_app(sink=None, data=None):
    return _manager.init_app(sink=sink, data=data)


def login(host: str, port: int, username: str, password: str = ''):
    return _manager.login(host=host, port=port, username=username, password=password)


def logout():
    return _manager.logout()


def tick():
    return _manager.tick()


def add_sub(topic: str):
    return _manager.add_sub(topic)


def is_connected() -> bool:
    return _manager.is_connected()


def get_username() -> Optional[str]:
    return _manager.get_username()


def get_status() -> Dict[str, Any]:
    return _manager.get_status()


def chat_local(user: str, text: str):
    return _manager.chat_local(user, text)
