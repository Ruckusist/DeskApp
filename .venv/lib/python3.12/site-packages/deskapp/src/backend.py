import time
from timeit import default_timer as timer
from deskapp import SubClass, Keys

class Backend(SubClass):
    def __init__(self, app):
        super().__init__(app)
        self.should_stop = False
        self.update_timeout = .1
        self.last_update = timer()

        # display toggles.
        #self.screen_size_changed = False
        self.show_header    = app.show_header
        self.show_footer    = app.show_footer
        self.show_menu      = app.show_menu
        self.show_messages  = app.show_messages
        self.show_main      = app.show_main

        self.footer_buffer  = ""
        self.menu_w         = 15
        self.message_h      = 3
        self.messages_w     = 20

        self.redraw_mains()
        self.prev_panels_shown = (self.show_header, self.show_footer,
                                  self.show_menu, self.show_messages,
                                  self.show_main)

    def redraw_mains(self):
        self.header_panel    = self.draw_header()
        self.footer_panel    = self.draw_footer()
        self.menu_panel      = self.draw_menu()
        self.messages_panel  = self.draw_messages()

    def setup_mods(self):
        # first time setup of all mods.
        for mod in self.app.menu:
            self.setup_mod(mod)

    def _calc_main_dims(self):
        height      = self.front.h
        if self.show_header: height -= 3
        if self.show_footer: height -= 3
        message_split = int(height*self.app.v_split)
        if self.show_messages: height -= message_split
        top_left_x  = 0
        if self.show_header: top_left_x += 3

        menu_split = int(self.front.w*self.app.h_split)
        width       = self.front.w
        if self.show_menu: width -= menu_split
        top_left_y  = 0
        if self.show_menu: top_left_y += menu_split

        return [height, width, top_left_x, top_left_y]

    def setup_mod(self, mod):
        # class_id = random.random()
        active_module = mod(self.app)
        dims = self._calc_main_dims()
        panel       = self.front.make_panel(dims, active_module.name, box=self.app.show_box, banner=self.app.show_banner)
        self.app.logic.available_panels[mod.name] = [active_module, panel, dims]

    def redraw_mods(self):
        dims = self._calc_main_dims()
        for mod_name in self.app.logic.available_panels:
            active = self.app.logic.available_panels[mod_name]
            panel = self.front.make_panel(dims, active[0].name, box=self.app.show_box, banner=self.app.show_banner)
            active[1] = panel
            active[2] = dims

    def draw_header(self):
        height      = 3
        width       = self.front.w
        top_left_x  = 0
        top_left_y  = 0
        dims        = [height, width, top_left_x, top_left_y]
        dims_string = ' ,'.join([str(x) for x in dims])
        # self.print(f"Header dims: {dims_string}")
        panel       = self.front.make_panel(dims, self.app.title)
        return panel

    def draw_footer(self):
        height      = 3
        width       = self.front.w
        top_left_x  = self.front.h - 3
        top_left_y  = 0
        dims        = [height, width, top_left_x, top_left_y]
        panel       = self.front.make_panel(dims, "Input")
        if not self.front.key_mode:
            panel.win.addstr(1,2, f"Press <tab> to enter text; <h> for help.", self.front.color_green)
        return panel

    def draw_menu(self):
        height = self.front.h
        if self.show_footer:
            height -= 3
        if self.show_header:
            height -= 3

        menu_split = int(self.front.w * self.app.h_split)
        width = menu_split
        top_left_x = 0
        if self.show_header:
            top_left_x += 3
        top_left_y = 0

        dims = [height, width, top_left_x, top_left_y]
        self.menu_w = width
        # Usable inner height (minus top/bottom box)
        self.menu_h = max(0, height - 2)
        panel = self.front.make_panel(dims, "Menu")
        return panel

    def draw_messages(self):
        height      = self.front.h
        if self.show_header: height -= 3
        if self.show_footer: height -= 3
        top_left_x  = 0
        if self.show_header: top_left_x += 3
        if self.show_main:
            message_split = int(height*self.app.v_split)
            height -= message_split
            top_left_x += height
            height = message_split

        menu_split = int(self.front.w*self.app.h_split)
        width       = self.front.w
        if self.show_menu: width -= menu_split
        top_left_y  = 0
        if self.show_menu: top_left_y += menu_split

        dims = [height, width, top_left_x, top_left_y]
        self.messages_h = dims[0]-2
        self.messages_w = dims[1]-2
        panel       = self.front.make_panel(dims, "Messages")
        return panel

    def update_header(self):
        try:
            text = str(self.app.header)
            maxw = max(0, self.front.w - 4)
            if len(text) > maxw:
                text = text[:maxw]
            self.header_panel.win.addstr(1,3, text, self.front.color_blue)
        except Exception:
            pass

    def update_footer(self):
        try:
            if self.front.key_mode:
                maxw = max(0, self.front.w - 6)
                buf = self.front.key_buffer[:maxw]
                pad = " " * max(0, maxw - len(buf))
                self.footer_panel.win.addstr(1,2, f": {buf}{pad}", self.front.color_yellow)
            else:
                text = "Press <tab> to enter text; <h> for help."
                maxw = max(0, self.front.w - 4)
                if len(text) > maxw:
                    text = text[:maxw]
                self.footer_panel.win.addstr(1,2, text, self.front.color_green)
        except Exception:
            pass

    def update_messages(self):
        try:
            max_lines = max(0, self.messages_h)
        except Exception:
            max_lines = 0
        # Only render what fits
        lines = list(self.app.data['messages'])[-max_lines:]
        for idx, mesg in enumerate(lines):
            if idx >= max_lines:
                break
            text = str(mesg)
            width = max(0, self.messages_w - 2)
            if len(text) > width:
                text = text[:width]
            else:
                text = text + (" " * (width - len(text)))
            y = idx + 1
            x = 1
            try:
                self.messages_panel.win.addstr(y, x, text, self.front.color_cyan)
            except Exception:
                # Swallow draw errors to avoid crashing the UI
                pass

    def update_menu(self):
        max_lines = getattr(self, 'menu_h', max(0, self.front.h - 2))
        max_text_w = max(0, self.menu_w - 2)
        cur = self.app.logic.current
        for i, mod in enumerate(self.app.menu[:max_lines]):
            try:
                text = str(mod.name)
                if len(text) > max_text_w:
                    text = text[:max_text_w]
                color = self.front.color_select if i == cur else self.front.color_red
                self.menu_panel.win.addstr(i+1, 1, text, color)
            except Exception:
                # avoid crashing on draw errors
                pass

    def loop(self):
        # HANDLE THE INPUT
        key_mouse = self.front.get_input()
        if key_mouse == Keys.RESIZE:
            self.front.resized()
        else:
            self.app.logic.decider( key_mouse )

        # HANDLE PANEL RESIZE ->
        cur_panels_shown = (self.show_header, self.show_footer, self.show_menu, self.show_messages, self.show_main)
        if ((cur_panels_shown != self.prev_panels_shown) or
            self.front.has_resized_happened):
            # self.print("Resizing...")
            self.redraw_mains()
            self.redraw_mods()
            self.front.has_resized_happened = False

        # RUN A FRAME ON EVERY MOD
        for mod in self.app.logic.available_panels:
            self.app.logic.available_panels[mod][0].page(
                self.app.logic.available_panels[mod][1] )

        # UPDATE THE BUILT IN STUFF.
        self.update_messages()
        self.update_header()
        self.update_footer()
        self.update_menu()

        # REDRAW THE SCREEN
        if self.show_header:   self.header_panel.panel.show()
        else:                  self.header_panel.panel.hide()
        if self.show_footer:   self.footer_panel.panel.show()
        else:                  self.footer_panel.panel.hide()
        if self.show_menu:     self.menu_panel.panel.show()
        else:                  self.menu_panel.panel.hide()
        if self.show_messages: self.messages_panel.panel.show()
        else:                  self.messages_panel.panel.hide()
        cur_panel = self.app.logic.current_panel()
        if self.show_main:
            cur_panel.panel.show()
            cur_panel.panel.top()
        else:
            for mod in self.app.logic.available_panels:
                self.app.logic.available_panels[mod][1].panel.hide()

        self.front.curses.panel.update_panels()
        self.front.screen.refresh()

        self.prev_panels_shown = cur_panels_shown

    def main(self):
        self.setup_mods()

        while True:
            if self.should_stop:
                for mod in self.app.logic.available_panels:
                    self.app.logic.available_panels[mod][0].end_safely()
                break

            try:
                start_loop_time = timer()
                self.loop()
                loop_runtime = timer() - start_loop_time
                sleepfor = self.update_timeout - loop_runtime
                if sleepfor < 0:
                    sleepfor = 0
                time.sleep(sleepfor)

            except KeyboardInterrupt:
                break

            except Exception as e:
                if not self.should_stop:
                    self.print(f"Error off main loop: {e} ** carrying on **")
                raise


        self.front.end_safely()
    # Avoid direct console print on shutdown to keep screen clean
