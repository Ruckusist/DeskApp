import subprocess
from deskapp import SubClass, Keys, callback, callbacks



class Module(SubClass):
    name = "Basic Module"
    def __init__(self, app, class_id):
        super().__init__(app)
        self.class_id = class_id
        self.cur_el = 0
        self.elements = []
        self.scroll = 0
        self.scroll_elements = []
        self.input_string = ""
        self.mouse_input = None
        # Generic per-module storage to reduce boilerplate in mods
        self.context = {}

    @property
    def h(self):
        return self.app.logic.current_dims()[0]

    @property
    def w(self):
        return self.app.logic.current_dims()[1]
    
    def write(self, panel, x, y, string, color=None):
        if color == "yellow":
            c = self.front.color_yellow
        elif color == "red":
            c = self.front.color_red
        elif color == "green":
            c = self.front.color_green
        elif color == "blue":
            c = self.front.color_blue
        elif color == "black":
            c = self.front.color_black        
        else: 
            c = self.front.color_white
        if x >= self.h: 
            self.print("printed too many rows (x)")
            return
        if y >= self.w:
            self.print("printed off screen (y)")
            return
        if len(string) > self.w-y:
            self.print("string is too long")
            return
        panel.win.addstr(x, y, string,c)

    def element_scroller(self, panel):
        # self.index = 3
        for index, element in enumerate(self.scroll_elements):
            color = self.front.chess_white if index is not self.scroll else self.front.color_black
            cursor = ">> " if index is self.scroll else "   "
            panel.win.addstr(index+self.index, 2, cursor+element, color)
        self.index += len(self.scroll_elements)

    def register_module(self):
        self.app.menu.append(self)

    def page(self, panel):
        panel.win.addstr(2,2,"This is working!")

    def mouse_decider(self, mouse): pass

    def string_decider(self, input_string):
        """Called when the user submits text in input mode (press Enter after Tab).
        Subclasses can override this, or more simply override handle_text()."""
        self.input_string = input_string
        try:
            self.handle_text(input_string)
        except Exception as e:
            self.print(f"Error handling text input: {e}")

    def end_safely(self): pass

    # Convenience hooks and helpers for building modules
    def handle_text(self, input_string: str):
        """Hook for subclasses: handle submitted text.
        Override in your module instead of string_decider for simplicity."""
        # Default behavior: log minimal debug
        self.print(f"Input: {input_string}")

    def run_shell(self, command: str, timeout: int = 10):
        """Run a shell command and return (returncode, stdout_lines, stderr_lines).
        Intended to avoid boilerplate in modules that need to shell out."""
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            out_lines = result.stdout.splitlines() if result.stdout else []
            err_lines = result.stderr.splitlines() if result.stderr else []
            return result.returncode, out_lines, err_lines
        except subprocess.TimeoutExpired:
            return 124, [], ["Command timed out"]
        except Exception as e:
            return 1, [], [f"Error: {e}"]

    def render_lines(self, panel, lines, start_line: int = 1, color=None, max_lines: int = None):
        """Render a list of strings into the given panel with bounds checks and truncation.
        Returns the next line index after rendering."""
        if color is None:
            color = self.front.color_white
        h = self.h
        w = self.w
        if max_lines is None:
            max_lines = max(0, h - start_line - 1)
        # Only render the tail that fits
        to_render = list(lines)[-max_lines:]
        for i, line in enumerate(to_render):
            y = start_line + i
            if y >= h - 1:
                break
            text = str(line)
            if len(text) > w - 2:
                text = text[:w-2]
            try:
                panel.win.addstr(y, 1, text, color)
            except Exception as e:
                # Best-effort: try to indicate a draw error
                try:
                    panel.win.addstr(y, 1, f"Draw err: {str(e)[:18]}", self.front.color_error)
                except:
                    pass
        return start_line + len(to_render)

    @callback(0, keypress=Keys.UP)
    def on_up(self, *args, **kwargs):
        if self.scroll < 1:
            self.scroll = len(self.scroll_elements)-1
        else: self.scroll -= 1

    @callback(0, keypress=Keys.DOWN)
    def on_down(self, *args, **kwargs):
        """scroll down"""
        if self.scroll < len(self.scroll_elements)-1:
            self.scroll += 1
        else: self.scroll = 0

    @callback(0, keypress=Keys.RIGHT)
    def on_left(self, *args, **kwargs):
        """rotate clickable elements"""
        if self.cur_el < len(self.elements)-1:
            self.cur_el += 1
        else: self.cur_el = 0

    @callback(0, keypress=Keys.LEFT)
    def on_right(self, *args, **kwargs):
        """rotate clickable elements"""
        if self.cur_el > 0:
            self.cur_el -= 1
        else: self.cur_el = len(self.elements)-1

